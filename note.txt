package scanner

import (
	"bufio"
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/charmbracelet/lipgloss"
)

var (
	scanStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFD700")).
			Bold(true)

	openStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#00FF00"))

	closedStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FF6B6B"))

	infoStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#87CEEB"))

	errorStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FF4444"))

	warningStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFA500"))
)

type ScanType int

const (
	TCPScan ScanType = iota
	UDPScan
	SYNScan // Requires root privileges
	ConnectScan
)

type Scanner struct {
	timeout       time.Duration
	verbose       bool
	version       bool
	maxWorkers    int
	scanType      ScanType
	userAgent     string
	skipHostDown  bool
	outputFormat  string // json, xml, plain
	rateLimit     time.Duration
	retries       int
	proxyURL      string
}

type ScannerConfig struct {
	Timeout      time.Duration
	Verbose      bool
	Version      bool
	MaxWorkers   int
	ScanType     ScanType
	UserAgent    string
	SkipHostDown bool
	OutputFormat string
	RateLimit    time.Duration
	Retries      int
	ProxyURL     string
}

func New(config ScannerConfig) *Scanner {
	if config.Timeout == 0 {
		config.Timeout = 3 * time.Second
	}
	if config.MaxWorkers == 0 {
		config.MaxWorkers = 100
	}
	if config.UserAgent == "" {
		config.UserAgent = "Advanced-Port-Scanner/2.0"
	}
	if config.Retries == 0 {
		config.Retries = 1
	}

	return &Scanner{
		timeout:      config.Timeout,
		verbose:      config.Verbose,
		version:      config.Version,
		maxWorkers:   config.MaxWorkers,
		scanType:     config.ScanType,
		userAgent:    config.UserAgent,
		skipHostDown: config.SkipHostDown,
		outputFormat: config.OutputFormat,
		rateLimit:    config.RateLimit,
		retries:      config.Retries,
		proxyURL:     config.ProxyURL,
	}
}

type ScanResult struct {
	Host        string            `json:"host"`
	Port        int               `json:"port"`
	Protocol    string            `json:"protocol"`
	Service     string            `json:"service"`
	Version     string            `json:"version,omitempty"`
	Banner      string            `json:"banner,omitempty"`
	Open        bool              `json:"open"`
	Filtered    bool              `json:"filtered,omitempty"`
	State       string            `json:"state"`
	ResponseTime time.Duration    `json:"response_time"`
	SSL         *SSLInfo          `json:"ssl,omitempty"`
	HTTP        *HTTPInfo         `json:"http,omitempty"`
	Vulnerabilities []string      `json:"vulnerabilities,omitempty"`
	Headers     map[string]string `json:"headers,omitempty"`
	Timestamp   time.Time         `json:"timestamp"`
}

type SSLInfo struct {
	Version     string    `json:"version"`
	Cipher      string    `json:"cipher"`
	Issuer      string    `json:"issuer"`
	Subject     string    `json:"subject"`
	NotBefore   time.Time `json:"not_before"`
	NotAfter    time.Time `json:"not_after"`
	Fingerprint string    `json:"fingerprint"`
}

type HTTPInfo struct {
	StatusCode int               `json:"status_code"`
	Server     string            `json:"server"`
	Title      string            `json:"title"`
	Headers    map[string]string `json:"headers"`
	Redirects  []string          `json:"redirects,omitempty"`
}

type HostScanResult struct {
	Host         string       `json:"host"`
	IsAlive      bool         `json:"is_alive"`
	OpenPorts    []ScanResult `json:"open_ports"`
	ClosedPorts  []ScanResult `json:"closed_ports,omitempty"`
	FilteredPorts []ScanResult `json:"filtered_ports,omitempty"`
	ScanTime     time.Duration `json:"scan_time"`
	Timestamp    time.Time    `json:"timestamp"`
	OS          *OSInfo      `json:"os,omitempty"`
}

type OSInfo struct {
	Name       string  `json:"name"`
	Version    string  `json:"version"`
	Confidence float64 `json:"confidence"`
	Details    string  `json:"details"`
}

func (s *Scanner) ScanHost(host, portRange string) (*HostScanResult, error) {
	start := time.Now()
	
	if s.verbose {
		fmt.Println(scanStyle.Render(fmt.Sprintf("Starting scan of %s", host)))
	}

	// Check if host is alive first
	if !s.skipHostDown && !s.isHostAlive(host) {
		if s.verbose {
			fmt.Println(warningStyle.Render(fmt.Sprintf("Host %s appears to be down", host)))
		}
		return &HostScanResult{
			Host:      host,
			IsAlive:   false,
			Timestamp: time.Now(),
			ScanTime:  time.Since(start),
		}, nil
	}

	ports, err := s.parsePorts(portRange)
	if err != nil {
		return nil, fmt.Errorf("failed to parse port range: %w", err)
	}

	results := s.scanPorts(host, ports)
	
	hostResult := &HostScanResult{
		Host:      host,
		IsAlive:   true,
		Timestamp: time.Now(),
		ScanTime:  time.Since(start),
	}

	// Separate results by state
	for _, result := range results {
		if result.Open {
			hostResult.OpenPorts = append(hostResult.OpenPorts, result)
		} else if result.Filtered {
			hostResult.FilteredPorts = append(hostResult.FilteredPorts, result)
		} else {
			hostResult.ClosedPorts = append(hostResult.ClosedPorts, result)
		}
	}

	// Sort ports
	sort.Slice(hostResult.OpenPorts, func(i, j int) bool {
		return hostResult.OpenPorts[i].Port < hostResult.OpenPorts[j].Port
	})

	// Attempt OS detection
	if len(hostResult.OpenPorts) > 0 {
		hostResult.OS = s.detectOS(host, hostResult.OpenPorts)
	}

	s.displayResults(hostResult)
	return hostResult, nil
}

// ScanRange implements IP range scanning (the TODO from original code)
func (s *Scanner) ScanRange(ipRange, portRange string) ([]*HostScanResult, error) {
	fmt.Println(scanStyle.Render(fmt.Sprintf("Scanning range %s...", ipRange)))
	
	hosts, err := s.parseIPRange(ipRange)
	if err != nil {
		return nil, fmt.Errorf("failed to parse IP range: %w", err)
	}

	var results []*HostScanResult
	var mu sync.Mutex
	var wg sync.WaitGroup

	// Limit concurrent host scans
	sem := make(chan struct{}, 10)
	
	for _, host := range hosts {
		wg.Add(1)
		go func(h string) {
			defer wg.Done()
			sem <- struct{}{}
			defer func() { <-sem }()

			result, err := s.ScanHost(h, portRange)
			if err != nil {
				if s.verbose {
					fmt.Printf(errorStyle.Render("Error scanning %s: %v\n"), h, err)
				}
				return
			}

			mu.Lock()
			results = append(results, result)
			mu.Unlock()
		}(host)
	}

	wg.Wait()
	return results, nil
}

func (s *Scanner) parseIPRange(ipRange string) ([]string, error) {
	var hosts []string

	if strings.Contains(ipRange, "/") {
		// CIDR notation
		_, ipNet, err := net.ParseCIDR(ipRange)
		if err != nil {
			return nil, err
		}

		for ip := ipNet.IP.Mask(ipNet.Mask); ipNet.Contains(ip); s.incrementIP(ip) {
			hosts = append(hosts, ip.String())
		}
	} else if strings.Contains(ipRange, "-") {
		// Range notation (e.g., 192.168.1.1-192.168.1.100)
		parts := strings.Split(ipRange, "-")
		if len(parts) != 2 {
			return nil, fmt.Errorf("invalid IP range format")
		}

		startIP := net.ParseIP(strings.TrimSpace(parts[0]))
		endIP := net.ParseIP(strings.TrimSpace(parts[1]))
		
		if startIP == nil || endIP == nil {
			return nil, fmt.Errorf("invalid IP addresses in range")
		}

		for ip := startIP; !ip.Equal(endIP); s.incrementIP(ip) {
			hosts = append(hosts, ip.String())
		}
		hosts = append(hosts, endIP.String()) // Include end IP
	} else {
		// Single IP or hostname
		hosts = append(hosts, ipRange)
	}

	return hosts, nil
}

func (s *Scanner) incrementIP(ip net.IP) {
	for j := len(ip) - 1; j >= 0; j-- {
		ip[j]++
		if ip[j] > 0 {
			break
		}
	}
}

func (s *Scanner) parsePorts(portRange string) ([]int, error) {
	var ports []int

	if portRange == "" {
		// Default common ports
		return []int{21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 1433, 1521, 3306, 3389, 5432, 5900, 6379, 8080, 9200}, nil
	}

	parts := strings.Split(portRange, ",")
	for _, part := range parts {
		part = strings.TrimSpace(part)
		
		if strings.Contains(part, "-") {
			rangeParts := strings.Split(part, "-")
			if len(rangeParts) != 2 {
				return nil, fmt.Errorf("invalid port range: %s", part)
			}
			
			start, err := strconv.Atoi(strings.TrimSpace(rangeParts[0]))
			if err != nil {
				return nil, fmt.Errorf("invalid start port: %s", rangeParts[0])
			}
			
			end, err := strconv.Atoi(strings.TrimSpace(rangeParts[1]))
			if err != nil {
				return nil, fmt.Errorf("invalid end port: %s", rangeParts[1])
			}
			
			if start > end || start < 1 || end > 65535 {
				return nil, fmt.Errorf("invalid port range: %d-%d", start, end)
			}
			
			for i := start; i <= end; i++ {
				ports = append(ports, i)
			}
		} else {
			port, err := strconv.Atoi(part)
			if err != nil {
				return nil, fmt.Errorf("invalid port: %s", part)
			}
			
			if port < 1 || port > 65535 {
				return nil, fmt.Errorf("port out of range: %d", port)
			}
			
			ports = append(ports, port)
		}
	}

	return ports, nil
}

func (s *Scanner) scanPorts(host string, ports []int) []ScanResult {
	var results []ScanResult
	var mu sync.Mutex
	var wg sync.WaitGroup

	sem := make(chan struct{}, s.maxWorkers)

	for _, port := range ports {
		wg.Add(1)
		go func(p int) {
			defer wg.Done()
			sem <- struct{}{}
			defer func() { <-sem }()

			// Rate limiting
			if s.rateLimit > 0 {
				time.Sleep(s.rateLimit)
			}

			result := s.scanPort(host, p)
			
			mu.Lock()
			results = append(results, result)
			mu.Unlock()

			if s.verbose {
				s.printPortResult(result)
			}
		}(port)
	}

	wg.Wait()
	return results
}

func (s *Scanner) scanPort(host string, port int) ScanResult {
	start := time.Now()
	result := ScanResult{
		Host:      host,
		Port:      port,
		Protocol:  "tcp",
		Service:   s.getServiceName(port),
		Timestamp: time.Now(),
	}

	var isOpen bool
	var err error

	// Retry logic
	for i := 0; i <= s.retries; i++ {
		isOpen, err = s.isPortOpen(host, port)
		if err == nil {
			break
		}
		if i < s.retries {
			time.Sleep(time.Duration(i+1) * 100 * time.Millisecond)
		}
	}

	result.ResponseTime = time.Since(start)
	result.Open = isOpen

	if isOpen {
		result.State = "open"
		
		// Get banner and version info
		if s.version {
			result.Banner = s.getBanner(host, port)
			result.Version = s.detectVersion(host, port, result.Banner)
		}

		// Additional service-specific checks
		switch port {
		case 80, 8080, 3000, 8000:
			result.HTTP = s.getHTTPInfo(host, port, false)
		case 443, 8443:
			result.HTTP = s.getHTTPInfo(host, port, true)
			result.SSL = s.getSSLInfo(host, port)
		case 21, 22, 25, 110, 143, 993, 995:
			if result.Banner == "" {
				result.Banner = s.getBanner(host, port)
			}
		}

		// Basic vulnerability checks
		result.Vulnerabilities = s.checkVulnerabilities(host, port, result.Service, result.Banner)
	} else {
		if err != nil && strings.Contains(err.Error(), "timeout") {
			result.State = "filtered"
			result.Filtered = true
		} else {
			result.State = "closed"
		}
	}

	return result
}

func (s *Scanner) isHostAlive(host string) bool {
	// Try to resolve the hostname first
	_, err := net.LookupHost(host)
	if err != nil {
		return false
	}

	// Try connecting to common ports
	commonPorts := []int{80, 443, 22, 21, 25}
	for _, port := range commonPorts {
		if open, _ := s.isPortOpen(host, port); open {
			return true
		}
	}

	// Try ICMP ping (basic implementation)
	conn, err := net.DialTimeout("ip4:icmp", host, 2*time.Second)
	if err == nil {
		conn.Close()
		return true
	}

	return false
}

func (s *Scanner) isPortOpen(host string, port int) (bool, error) {
	address := fmt.Sprintf("%s:%d", host, port)
	
	switch s.scanType {
	case UDPScan:
		return s.isUDPPortOpen(host, port)
	default: // TCP scan
		conn, err := net.DialTimeout("tcp", address, s.timeout)
		if err != nil {
			return false, err
		}
		conn.Close()
		return true, nil
	}
}

func (s *Scanner) isUDPPortOpen(host string, port int) (bool, error) {
	address := fmt.Sprintf("%s:%d", host, port)
	conn, err := net.DialTimeout("udp", address, s.timeout)
	if err != nil {
		return false, err
	}
	defer conn.Close()

	// Send a simple probe
	_, err = conn.Write([]byte("probe"))
	if err != nil {
		return false, err
	}

	// Set read deadline
	conn.SetReadDeadline(time.Now().Add(s.timeout))
	buffer := make([]byte, 1024)
	_, err = conn.Read(buffer)
	
	// If we get any response, port is likely open
	return err == nil, nil
}

func (s *Scanner) getBanner(host string, port int) string {
	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", host, port), s.timeout)
	if err != nil {
		return ""
	}
	defer conn.Close()

	conn.SetReadDeadline(time.Now().Add(3 * time.Second))
	
	// Send protocol-specific probes
	switch port {
	case 80, 8080:
		conn.Write([]byte("GET / HTTP/1.0\r\n\r\n"))
	case 21:
		// FTP - just read the welcome banner
	case 22:
		// SSH - just read the version string
	case 25:
		// SMTP - read the greeting
	default:
		// Generic probe
		conn.Write([]byte("\r\n"))
	}

	buffer := make([]byte, 4096)
	n, err := conn.Read(buffer)
	if err != nil {
		return ""
	}

	banner := strings.TrimSpace(string(buffer[:n]))
	if len(banner) > 200 {
		banner = banner[:200] + "..."
	}

	return banner
}

func (s *Scanner) detectVersion(host string, port int, banner string) string {
	if banner == "" {
		return ""
	}

	// Common version detection patterns
	patterns := map[string]*regexp.Regexp{
		"SSH":    regexp.MustCompile(`SSH-([0-9.]+)`),
		"HTTP":   regexp.MustCompile(`Server:\s*([^\r\n]+)`),
		"FTP":    regexp.MustCompile(`([0-9.]+)`),
		"Apache": regexp.MustCompile(`Apache/([0-9.]+)`),
		"nginx":  regexp.MustCompile(`nginx/([0-9.]+)`),
		"OpenSSH": regexp.MustCompile(`OpenSSH_([0-9.]+)`),
	}

	for service, pattern := range patterns {
		if matches := pattern.FindStringSubmatch(banner); len(matches) > 1 {
			return fmt.Sprintf("%s %s", service, matches[1])
		}
	}

	// Return first line of banner as version info
	lines := strings.Split(banner, "\n")
	if len(lines) > 0 && len(lines[0]) > 0 {
		return strings.TrimSpace(lines[0])
	}

	return ""
}

func (s *Scanner) getHTTPInfo(host string, port int, useSSL bool) *HTTPInfo {
	protocol := "http"
	if useSSL {
		protocol = "https"
	}

	url := fmt.Sprintf("%s://%s:%d", protocol, host, port)
	
	client := &http.Client{
		Timeout: s.timeout,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			if len(via) >= 5 {
				return http.ErrUseLastResponse
			}
			return nil
		},
	}

	if useSSL {
		client.Transport = &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
	}

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil
	}

	req.Header.Set("User-Agent", s.userAgent)

	resp, err := client.Do(req)
	if err != nil {
		return nil
	}
	defer resp.Body.Close()

	info := &HTTPInfo{
		StatusCode: resp.StatusCode,
		Headers:    make(map[string]string),
	}

	// Extract headers
	for key, values := range resp.Header {
		if len(values) > 0 {
			info.Headers[key] = values[0]
			if key == "Server" {
				info.Server = values[0]
			}
		}
	}

	// Try to extract title
	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		line := scanner.Text()
		if titleMatch := regexp.MustCompile(`<title[^>]*>([^<]+)</title>`).FindStringSubmatch(line); len(titleMatch) > 1 {
			info.Title = strings.TrimSpace(titleMatch[1])
			break
		}
	}

	return info
}

func (s *Scanner) getSSLInfo(host string, port int) *SSLInfo {
	conn, err := tls.DialWithDialer(&net.Dialer{Timeout: s.timeout}, "tcp", 
		fmt.Sprintf("%s:%d", host, port), &tls.Config{InsecureSkipVerify: true})
	if err != nil {
		return nil
	}
	defer conn.Close()

	state := conn.ConnectionState()
	if len(state.PeerCertificates) == 0 {
		return nil
	}

	cert := state.PeerCertificates[0]
	
	return &SSLInfo{
		Version:     s.getTLSVersion(state.Version),
		Cipher:      tls.CipherSuiteName(state.CipherSuite),
		Issuer:      cert.Issuer.String(),
		Subject:     cert.Subject.String(),
		NotBefore:   cert.NotBefore,
		NotAfter:    cert.NotAfter,
		Fingerprint: fmt.Sprintf("%x", cert.Raw)[:32], // First 32 chars of fingerprint
	}
}

func (s *Scanner) getTLSVersion(version uint16) string {
	switch version {
	case tls.VersionTLS10:
		return "TLS 1.0"
	case tls.VersionTLS11:
		return "TLS 1.1"
	case tls.VersionTLS12:
		return "TLS 1.2"
	case tls.VersionTLS13:
		return "TLS 1.3"
	default:
		return "Unknown"
	}
}

func (s *Scanner) checkVulnerabilities(host string, port int, service, banner string) []string {
	var vulns []string

	// Basic vulnerability checks based on service and version
	if strings.Contains(strings.ToLower(banner), "openssh") {
		if strings.Contains(banner, "OpenSSH_7.4") {
			vulns = append(vulns, "CVE-2018-15473: Username enumeration")
		}
	}

	if service == "http" || service == "https" {
		if strings.Contains(strings.ToLower(banner), "apache/2.4.49") {
			vulns = append(vulns, "CVE-2021-41773: Path traversal")
		}
	}

	// Check for common weak configurations
	if port == 21 && strings.Contains(strings.ToLower(banner), "ftp") {
		vulns = append(vulns, "Potential: Anonymous FTP access")
	}

	if port == 23 {
		vulns = append(vulns, "Security Risk: Telnet (unencrypted protocol)")
	}

	return vulns
}

func (s *Scanner) detectOS(host string, openPorts []ScanResult) *OSInfo {
	// Simple OS detection based on open ports and services
	// This is a basic implementation - real OS detection is much more complex
	
	hasSSH := false
	hasRDP := false
	hasSMB := false
	
	for _, port := range openPorts {
		switch port.Port {
		case 22:
			hasSSH = true
		case 3389:
			hasRDP = true
		case 135, 139, 445:
			hasSMB = true
		}
	}

	if hasRDP && hasSMB {
		return &OSInfo{
			Name:       "Windows",
			Confidence: 0.8,
			Details:    "Detected based on RDP and SMB ports",
		}
	}

	if hasSSH && !hasRDP {
		return &OSInfo{
			Name:       "Linux/Unix",
			Confidence: 0.7,
			Details:    "Detected based on SSH presence and no RDP",
		}
	}

	return nil
}

func (s *Scanner) getServiceName(port int) string {
	services := map[int]string{
		20:    "ftp-data",
		21:    "ftp",
		22:    "ssh",
		23:    "telnet",
		25:    "smtp",
		53:    "dns",
		67:    "dhcp",
		68:    "dhcp",
		69:    "tftp",
		80:    "http",
		110:   "pop3",
		123:   "ntp",
		135:   "msrpc",
		137:   "netbios-ns",
		138:   "netbios-dgm",
		139:   "netbios-ssn",
		143:   "imap",
		161:   "snmp",
		162:   "snmptrap",
		179:   "bgp",
		389:   "ldap",
		443:   "https",
		445:   "microsoft-ds",
		465:   "smtps",
		514:   "syslog",
		515:   "printer",
		587:   "submission",
		631:   "ipp",
		636:   "ldaps",
		993:   "imaps",
		995:   "pop3s",
		1433:  "ms-sql-s",
		1521:  "oracle",
		1723:  "pptp",
		3306:  "mysql",
		3389:  "ms-wbt-server",
		5432:  "postgresql",
		5900:  "vnc",
		6379:  "redis",
		8080:  "http-proxy",
		8443:  "https-alt",
		9200:  "elasticsearch",
		9300:  "elasticsearch",
		27017: "mongodb",
	}

	if service, exists := services[port]; exists {
		return service
	}
	return "unknown"
}

func (s *Scanner) printPortResult(result ScanResult) {
	if result.Open {
		output := fmt.Sprintf("✓ %d/tcp %s", result.Port, result.Service)
		if result.Version != "" {
			output += fmt.Sprintf(" (%s)", result.Version)
		}
		fmt.Println(openStyle.Render(output))
	} else if result.Filtered {
		fmt.Println(warningStyle.Render(fmt.Sprintf("? %d/tcp %s (filtered)", result.Port, result.Service)))
	} else {
		fmt.Println(closedStyle.Render(fmt.Sprintf("✗ %d/tcp %s", result.Port, result.Service)))
	}
}

func (s *Scanner) displayResults(result *HostScanResult) {
	fmt.Println(scanStyle.Render(fmt.Sprintf("\n═══ Scan Results for %s ═══", result.Host)))
	fmt.Println(infoStyle.Render(fmt.Sprintf("Scan completed in %v", result.ScanTime)))
	
	if !result.IsAlive {
		fmt.Println(warningStyle.Render("Host appears to be down"))
		return
	}

	if result.OS != nil {
		fmt.Println(infoStyle.Render(fmt.Sprintf("OS Detection: %s (%.1f%% confidence)", 
			result.OS.Name, result.OS.Confidence*100)))
	}

	fmt.Printf("\n")
	fmt.Println(openStyle.Render(fmt.Sprintf("Open Ports (%d):", len(result.OpenPorts))))
	fmt.Println(strings.Repeat("─", 80))

	if len(result.OpenPorts) == 0 {
		fmt.Println(closedStyle.Render("No open ports found"))
	} else {
		for _, port := range result.OpenPorts {
			output := fmt.Sprintf("%-6d %-15s %-20s", port.Port, port.Protocol, port.Service)
			
			if port.Version != "" {
				output += fmt.Sprintf(" %s", port.Version)
			}
			
			if len(port.Vulnerabilities) > 0 {
				output += fmt.Sprintf(" [%s]", errorStyle.Render("VULN"))
			}
			
			fmt.Println(openStyle.Render(output))
			
			// Show additional details if verbose
			if s.verbose {
				if port.HTTP != nil {
					fmt.Printf("    HTTP: %d %s\n", port.HTTP.StatusCode, port.HTTP.Server)
					if port.HTTP.Title != "" {
						fmt.Printf("    Title: %s\n", port.HTTP.Title)
					}
				}
				
				if port.SSL != nil {
					fmt.Printf("    SSL: %s (%s)\n", port.SSL.Version, port.SSL.Cipher)
					fmt.Printf("    Cert: %s\n", port.SSL.Subject)
				}
				
				for _, vuln := range port.Vulnerabilities {
					fmt.Printf("    %s %s\n", errorStyle.Render("VULN:"), vuln)
				}
			}
		}
	}

	if s.verbose && len(result.FilteredPorts) > 0 {
		fmt.Printf("\n")
		fmt.Println(warningStyle.Render(fmt.Sprintf("Filtered Ports (%d):", len(result.FilteredPorts))))
		for _, port := range result.FilteredPorts {
			fmt.Printf("%-6d %s (filtered)\n", port.Port, port.Service)
		}
	}
	
	fmt.Printf("\n")
}

// ExportResults exports scan results in different formats
func (s *Scanner) ExportResults(results []*HostScanResult, format, filename string) error {
	switch strings.ToLower(format) {
	case "json":
		return s.exportJSON(results, filename)
	case "xml":
		return s.exportXML(results, filename)
	case "csv":
		return s.exportCSV(results, filename)
	default:
		return fmt.Errorf("unsupported export format: %s", format)
	}
}

func (s *Scanner) exportJSON(results []*HostScanResult, filename string) error {
	data, err := json.MarshalIndent(results, "", "  ")
	if err != nil {
		return err
	}
	
	// In a real implementation, you would write to file
	fmt.Printf("JSON Export (%s):\n%s\n", filename, string(data))
	return nil
}

func (s *Scanner) exportXML(results []*HostScanResult, filename string) error {
	// Basic XML export implementation
	xml := `<?xml version="1.0" encoding="UTF-8"?>
<scan_results>
`
	
	for _, result := range results {
		xml += fmt.Sprintf(`  <host name="%s" alive="%t">
`, result.Host, result.IsAlive)
		
		for _, port := range result.OpenPorts {
			xml += fmt.Sprintf(`    <port number="%d" protocol="%s" service="%s" state="%s">
`, port.Port, port.Protocol, port.Service, port.State)
			
			if port.Version != "" {
				xml += fmt.Sprintf(`      <version>%s</version>
`, port.Version)
			}
			
			xml += `    </port>
`
		}
		
		xml += `  </host>
`
	}
	
	xml += `</scan_results>`
	
	fmt.Printf("XML Export (%s):\n%s\n", filename, xml)
	return nil
}

func (s *Scanner) exportCSV(results []*HostScanResult, filename string) error {
	csv := "Host,Port,Protocol,Service,State,Version,Banner\n"
	
	for _, result := range results {
		for _, port := range result.OpenPorts {
			csv += fmt.Sprintf("%s,%d,%s,%s,%s,%s,%s\n",
				result.Host, port.Port, port.Protocol, port.Service,
				port.State, port.Version, strings.ReplaceAll(port.Banner, ",", ";"))
		}
	}
	
	fmt.Printf("CSV Export (%s):\n%s\n", filename, csv)
	return nil
}

// ScanWithContext allows for cancellable scans
func (s *Scanner) ScanWithContext(ctx context.Context, host, portRange string) (*HostScanResult, error) {
	resultChan := make(chan *HostScanResult, 1)
	errorChan := make(chan error, 1)
	
	go func() {
		result, err := s.ScanHost(host, portRange)
		if err != nil {
			errorChan <- err
			return
		}
		resultChan <- result
	}()
	
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case err := <-errorChan:
		return nil, err
	case result := <-resultChan:
		return result, nil
	}
}

// GetScanStatistics returns statistics about the scanner performance
func (s *Scanner) GetScanStatistics() map[string]interface{} {
	return map[string]interface{}{
		"timeout":      s.timeout,
		"max_workers":  s.maxWorkers,
		"scan_type":    s.getScanTypeName(),
		"rate_limit":   s.rateLimit,
		"retries":      s.retries,
		"user_agent":   s.userAgent,
	}
}

func (s *Scanner) getScanTypeName() string {
	switch s.scanType {
	case TCPScan:
		return "TCP Connect"
	case UDPScan:
		return "UDP"
	case SYNScan:
		return "SYN Stealth"
	case ConnectScan:
		return "TCP Connect"
	default:
		return "Unknown"
	}
}

// ValidateTarget checks if the target is valid and safe to scan
func (s *Scanner) ValidateTarget(target string) error {
	// Parse the target
	ip := net.ParseIP(target)
	if ip == nil {
		// Try to resolve hostname
		ips, err := net.LookupIP(target)
		if err != nil {
			return fmt.Errorf("invalid target: cannot resolve %s", target)
		}
		if len(ips) == 0 {
			return fmt.Errorf("no IP addresses found for %s", target)
		}
		ip = ips[0]
	}

	// Check for private/localhost ranges that might be sensitive
	if ip.IsLoopback() {
		return fmt.Errorf("scanning localhost is not recommended")
	}

	// Warn about scanning private networks (but don't block)
	if ip.IsPrivate() && s.verbose {
		fmt.Println(warningStyle.Render("Warning: Scanning private network address"))
	}

	return nil
}

// BatchScan performs scans on multiple targets
func (s *Scanner) BatchScan(targets []string, portRange string) ([]*HostScanResult, error) {
	var results []*HostScanResult
	var mu sync.Mutex
	var wg sync.WaitGroup
	
	// Limit concurrent scans
	sem := make(chan struct{}, 5)
	
	for _, target := range targets {
		// Validate target first
		if err := s.ValidateTarget(target); err != nil {
			if s.verbose {
				fmt.Printf(errorStyle.Render("Skipping %s: %v\n"), target, err)
			}
			continue
		}
		
		wg.Add(1)
		go func(t string) {
			defer wg.Done()
			sem <- struct{}{}
			defer func() { <-sem }()
			
			result, err := s.ScanHost(t, portRange)
			if err != nil {
				if s.verbose {
					fmt.Printf(errorStyle.Render("Error scanning %s: %v\n"), t, err)
				}
				return
			}
			
			mu.Lock()
			results = append(results, result)
			mu.Unlock()
		}(target)
	}
	
	wg.Wait()
	return results, nil
}

// ServiceScan performs detailed service enumeration
func (s *Scanner) ServiceScan(host string, port int) (*ScanResult, error) {
	result := s.scanPort(host, port)
	
	if !result.Open {
		return &result, nil
	}
	
	// Perform detailed service enumeration
	switch result.Service {
	case "http", "https":
		result.HTTP = s.getHTTPInfo(host, port, result.Service == "https")
		if result.Service == "https" {
			result.SSL = s.getSSLInfo(host, port)
		}
		
		// Additional HTTP checks
		result.Headers = s.getHTTPHeaders(host, port, result.Service == "https")
		
	case "ssh":
		// SSH-specific enumeration
		result.Banner = s.getBanner(host, port)
		result.Version = s.detectVersion(host, port, result.Banner)
		
	case "ftp":
		// FTP-specific checks
		result.Banner = s.getBanner(host, port)
		// Check for anonymous access
		if s.checkAnonymousFTP(host, port) {
			result.Vulnerabilities = append(result.Vulnerabilities, "Anonymous FTP access enabled")
		}
	}
	
	return &result, nil
}

func (s *Scanner) getHTTPHeaders(host string, port int, useSSL bool) map[string]string {
	protocol := "http"
	if useSSL {
		protocol = "https"
	}
	
	url := fmt.Sprintf("%s://%s:%d", protocol, host, port)
	
	client := &http.Client{
		Timeout: s.timeout / 2, // Shorter timeout for header requests
	}
	
	if useSSL {
		client.Transport = &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
	}
	
	resp, err := client.Head(url)
	if err != nil {
		return nil
	}
	defer resp.Body.Close()
	
	headers := make(map[string]string)
	for key, values := range resp.Header {
		if len(values) > 0 {
			headers[key] = values[0]
		}
	}
	
	return headers
}

func (s *Scanner) checkAnonymousFTP(host string, port int) bool {
	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", host, port), s.timeout)
	if err != nil {
		return false
	}
	defer conn.Close()
	
	// Read welcome banner
	conn.SetReadDeadline(time.Now().Add(5 * time.Second))
	scanner := bufio.NewScanner(conn)
	scanner.Scan() // Read welcome message
	
	// Try anonymous login
	conn.Write([]byte("USER anonymous\r\n"))
	scanner.Scan()
	response := scanner.Text()
	
	if strings.Contains(response, "331") { // User name okay, need password
		conn.Write([]byte("PASS anonymous@example.com\r\n"))
		scanner.Scan()
		response = scanner.Text()
		
		return strings.Contains(response, "230") // User logged in
	}
	
	return false
}

// Example usage and main function would be in a separate file
/*
func main() {
	config := ScannerConfig{
		Timeout:      5 * time.Second,
		Verbose:      true,
		Version:      true,
		MaxWorkers:   50,
		ScanType:     TCPScan,
		OutputFormat: "json",
		RateLimit:    10 * time.Millisecond,
		Retries:      2,
	}
	
	scanner := New(config)
	
	// Single host scan
	result, err := scanner.ScanHost("example.com", "1-1000")
	if err != nil {
		fmt.Printf("Scan error: %v\n", err)
		return
	}
	
	// Export results
	scanner.ExportResults([]*HostScanResult{result}, "json", "scan_results.json")
	
	// Range scan
	rangeResults, err := scanner.ScanRange("192.168.1.0/24", "22,80,443")
	if err != nil {
		fmt.Printf("Range scan error: %v\n", err)
		return
	}
	
	fmt.Printf("Scanned %d hosts in range\n", len(rangeResults))
}
*/
